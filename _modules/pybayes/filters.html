

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pybayes.filters &mdash; PyBayes 0.3-96-g0efa257
 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.3-96-g0efa257
',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PyBayes 0.3-96-g0efa257
 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">PyBayes 0.3-96-g0efa257
 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pybayes.filters</h1><div class="highlight"><pre>
<span class="c"># Copyright (c) 2010 Matej Laitl &lt;matej@laitl.cz&gt;</span>
<span class="c"># Distributed under the terms of the GNU General Public License v2 or any</span>
<span class="c"># later version of the license, at your option.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains Bayesian filters.</span>

<span class="sd">All classes from this module are currently imported to top-level pybayes module,</span>
<span class="sd">so instead of ``from pybayes.filters import KalmanFilter`` you can type ``from</span>
<span class="sd">pybayes import KalmanFilter``.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">empty</span>

<span class="kn">from</span> <span class="nn">.wrappers</span> <span class="kn">import</span> <span class="n">_linalg</span> <span class="k">as</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">.wrappers</span> <span class="kn">import</span> <span class="n">_numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">.pdfs</span> <span class="kn">import</span> <span class="n">CPdf</span><span class="p">,</span> <span class="n">Pdf</span><span class="p">,</span> <span class="n">GaussPdf</span><span class="p">,</span> <span class="n">EmpPdf</span><span class="p">,</span> <span class="n">MarginalizedEmpPdf</span>


<div class="viewcode-block" id="Filter"><a class="viewcode-back" href="../../filters.html#pybayes.filters.Filter">[docs]</a><span class="k">class</span> <span class="nc">Filter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract prototype of a bayesian filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Filter.bayes"><a class="viewcode-back" href="../../filters.html#pybayes.filters.Filter.bayes">[docs]</a>    <span class="k">def</span> <span class="nf">bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform approximate or exact bayes rule.</span>

<span class="sd">        :param yt: observation at time t</span>
<span class="sd">        :type yt: 1D :class:`numpy.ndarray`</span>
<span class="sd">        :param cond: condition at time t. Exact meaning is defined by each filter</span>
<span class="sd">        :type cond: 1D :class:`numpy.ndarray`</span>
<span class="sd">        :return: always returns True (see :meth:`posterior` to get posterior density)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Derived classes must implement this method&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Filter.posterior"><a class="viewcode-back" href="../../filters.html#pybayes.filters.Filter.posterior">[docs]</a>    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return posterior probability density funcion (:class:`~pybayes.pdfs.CPdf`).</span>

<span class="sd">        :return: posterior density</span>
<span class="sd">        :rtype: :class:`~pybayes.pdfs.Pdf`</span>

<span class="sd">        *Filter implementations may decide to return a reference to their work pdf - it is not safe</span>
<span class="sd">        to modify it in any way, doing so may leave the filter in undefined state.*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Derived classes must implement this method&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Filter.evidence_log"><a class="viewcode-back" href="../../filters.html#pybayes.filters.Filter.evidence_log">[docs]</a>    <span class="k">def</span> <span class="nf">evidence_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the logarithm of *evidence* function (also known as *marginal likelihood*) evaluated</span>
<span class="sd">        in point yt.</span>

<span class="sd">        :param yt: point which to evaluate the evidence in</span>
<span class="sd">        :type yt: :class:`numpy.ndarray`</span>
<span class="sd">        :rtype: double</span>

<span class="sd">        This is typically computed after :meth:`bayes` with the same observation:</span>

<span class="sd">        &gt;&gt;&gt; filter.bayes(yt)</span>
<span class="sd">        &gt;&gt;&gt; log_likelihood = filter.evidence_log(yt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Derived classes should implement this method, if feasible&quot;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="KalmanFilter"><a class="viewcode-back" href="../../filters.html#pybayes.filters.KalmanFilter">[docs]</a><span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Filter</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Implementation of standard Kalman filter. **cond** in :meth:`bayes` is interpreted as</span>
<span class="sd">    control (intervention) input :math:`u_t` to the system.</span>

<span class="sd">    Kalman filter forms *optimal Bayesian solution* for the following system:</span>

<span class="sd">    .. math::</span>

<span class="sd">        x_t &amp;= A_t x_{t-1} + B_t u_t + v_{t-1} \quad \quad</span>
<span class="sd">            A_t \in \mathbb{R}^{n,n} \;\;</span>
<span class="sd">            B_t \in \mathbb{R}^{n,k} \;\;</span>
<span class="sd">            \;\; n \in \mathbb{N}</span>
<span class="sd">            \;\; k \in \mathbb{N}_0 \text{ (may be zero)}</span>
<span class="sd">            \\</span>
<span class="sd">        y_t &amp;= C_t x_t + D_t u_t + w_t \quad \quad \quad \;\;</span>
<span class="sd">            C_t \in \mathbb{R}^{j,n} \;\;</span>
<span class="sd">            D_t \in \mathbb{R}^{j,k} \;\;</span>
<span class="sd">            j \in \mathbb{N} \;\; j \leq n</span>

<span class="sd">    where :math:`x_t \in \mathbb{R}^n` is hidden state vector, :math:`y_t \in \mathbb{R}^j` is</span>
<span class="sd">    observation vector and :math:`u_t \in \mathbb{R}^k` is control vector. :math:`v_t` is normally</span>
<span class="sd">    distributed zero-mean process noise with covariance matrix :math:`Q_t`, :math:`w_t` is normally</span>
<span class="sd">    distributed zero-mean observation noise with covariance matrix :math:`R_t`. Additionally, intial</span>
<span class="sd">    pdf (**state_pdf**) has to be Gaussian.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KalmanFilter.__init__"><a class="viewcode-back" href="../../filters.html#pybayes.filters.KalmanFilter.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">state_pdf</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Initialise Kalman filter.</span>

<span class="sd">        :param A: process model matrix :math:`A_t` from :class:`class description &lt;KalmanFilter&gt;`</span>
<span class="sd">        :type A: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param B: process control model matrix :math:`B_t` from :class:`class description</span>
<span class="sd">           &lt;KalmanFilter&gt;`; may be None or unspecified for control-less systems</span>
<span class="sd">        :type B: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param C: observation model matrix :math:`C_t` from :class:`class description</span>
<span class="sd">           &lt;KalmanFilter&gt;`; must be full-ranked</span>
<span class="sd">        :type C: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param D: observation control model matrix :math:`D_t` from :class:`class description</span>
<span class="sd">           &lt;KalmanFilter&gt;`; may be None or unspecified for control-less systems</span>
<span class="sd">        :type D: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param Q: process noise covariance matrix :math:`Q_t` from :class:`class description</span>
<span class="sd">           &lt;KalmanFilter&gt;`; must be positive definite</span>
<span class="sd">        :type Q: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param R: observation noise covariance matrix :math:`R_t` from :class:`class description</span>
<span class="sd">           &lt;KalmanFilter&gt;`; must be positive definite</span>
<span class="sd">        :type R: 2D :class:`numpy.ndarray`</span>
<span class="sd">        :param state_pdf: initial state pdf; this object is referenced and used throughout whole</span>
<span class="sd">           life of KalmanFilter, so it is not safe to reuse state pdf for other purposes</span>
<span class="sd">        :type state_pdf: :class:`~pybayes.pdfs.GaussPdf`</span>

<span class="sd">        All matrices can be time-varying - you can modify or replace all above stated matrices</span>
<span class="sd">        providing that you don&#39;t change their shape and all constraints still hold. On the other</span>
<span class="sd">        hand, you **should not modify state_pdf** unless you really know what you are doing.</span>

<span class="sd">        &gt;&gt;&gt; # initialise control-less Kalman filter:</span>
<span class="sd">        &gt;&gt;&gt; kf = pb.KalmanFilter(A=np.array([[1.]]),</span>
<span class="sd">                                 C=np.array([[1.]]),</span>
<span class="sd">                                 Q=np.array([[0.7]]), R=np.array([[0.3]]),</span>
<span class="sd">                                 state_pdf=pb.GaussPdf(...))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># check type of pdf</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_pdf</span><span class="p">,</span> <span class="n">GaussPdf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;state_pdf must be (a subclass of) GaussPdf&quot;</span><span class="p">)</span>

        <span class="c"># check type of input arrays</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">:</span><span class="n">A</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">:</span><span class="n">B</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">:</span><span class="n">C</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">:</span><span class="n">D</span><span class="p">,</span> <span class="s">&quot;Q&quot;</span><span class="p">:</span><span class="n">Q</span><span class="p">,</span> <span class="s">&quot;R&quot;</span><span class="p">:</span><span class="n">R</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;B&#39;</span> <span class="ow">and</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># we allow B to be unspecified</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span> <span class="ow">and</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># we allow D to be unspecified</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;{0} must have 2 dimensions (forming a matrix) {1} given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="c"># remember vector shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">state_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>  <span class="c"># dimension of state vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># dimension of control vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># dimension of observation vector</span>

        <span class="c"># dict of required matrice shapes (sizes)</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;A&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span>
            <span class="s">&quot;B&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span>
            <span class="s">&quot;C&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span>
            <span class="s">&quot;D&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span>
            <span class="s">&quot;Q&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span>
            <span class="s">&quot;R&quot;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c"># check input matrix sizes</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">element_count</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shapes</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">element_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">matrix</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Given shapes of state_pdf, B and C, matrix &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span>
                                 <span class="s">&quot; must have shape &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; given&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">state_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">GaussPdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">]]))</span>  <span class="c"># observation probability density function</span>
</div>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># type(self) is used because this method may be called for a derived class</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c"># type(self) is used because this method may be called for a derived class</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c"># numeric arrays:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>  <span class="c"># no need to copy integers</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>  <span class="c"># GaussPdfs:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="KalmanFilter.bayes"><a class="viewcode-back" href="../../filters.html#pybayes.filters.KalmanFilter.bayes">[docs]</a>    <span class="k">def</span> <span class="nf">bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Perform exact bayes rule.</span>

<span class="sd">        :param yt: observation at time t</span>
<span class="sd">        :type yt: 1D :class:`numpy.ndarray`</span>
<span class="sd">        :param cond: control (intervention) vector at time t. May be unspecified if the filter is</span>
<span class="sd">           control-less.</span>
<span class="sd">        :type cond: 1D :class:`numpy.ndarray`</span>
<span class="sd">        :return: always returns True (see :meth:`~Filter.posterior` to get posterior density)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">yt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">yt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;yt must have shape {0}. ({1} given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,),</span> <span class="p">(</span><span class="n">yt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cond must have shape {0}. ({1} given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,),</span> <span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cond must be None as k == 0&quot;</span><span class="p">)</span>

        <span class="c"># predict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>  <span class="c"># prior state mean estimate</span>
        <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add_vv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>  <span class="c"># self.P.mu += self.B * cond</span>
        <span class="c"># prior state covariance estimate:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c"># self.P.R = self.A * self.P.R * self.A&#39;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>  <span class="c"># self.P.R += self.Q</span>

        <span class="c"># data update</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot_mv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>  <span class="c"># prior observation mean estimate; self.S.mu = self.C * self.P.mu</span>
        <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add_vv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>  <span class="c"># self.S.mu += self.D * cond</span>
        <span class="c"># prior observation covariance estimate:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>  <span class="c"># self.S.R = self.C * self.P.R * self.C&#39;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>  <span class="c"># self.S.R += self.R</span>

        <span class="c"># kalman gain</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>

        <span class="c"># update according to observation</span>
        <span class="c"># posterior state mean estimate:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add_vv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mv</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract_vv</span><span class="p">(</span><span class="n">yt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mu</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>  <span class="c"># self.P.mu += K * (yt - self.S.mu)</span>
        <span class="c"># posterior state covariance estimate:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">subtract_mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot_mm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>  <span class="c"># self.P.R -= K * self.C * self.P.R</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span>

    <span class="k">def</span> <span class="nf">evidence_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">eval_log</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ParticleFilter"><a class="viewcode-back" href="../../filters.html#pybayes.filters.ParticleFilter">[docs]</a><span class="k">class</span> <span class="nc">ParticleFilter</span><span class="p">(</span><span class="n">Filter</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Standard particle filter (or SIR filter, SMC method) implementation with resampling</span>
<span class="sd">    and optional support for proposal density.</span>

<span class="sd">    Posterior pdf is represented using :class:`~pybayes.pdfs.EmpPdf` and takes following form:</span>

<span class="sd">    .. math:: p(x_t|y_{1:t}) = \sum_{i=1}^n \omega_i \delta ( x_t - x_t^{(i)} )</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ParticleFilter.__init__"><a class="viewcode-back" href="../../filters.html#pybayes.filters.ParticleFilter.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">init_pdf</span><span class="p">,</span> <span class="n">p_xt_xtp</span><span class="p">,</span> <span class="n">p_yt_xt</span><span class="p">,</span> <span class="n">proposal</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Initialise particle filter.</span>

<span class="sd">        :param int n: number of particles</span>
<span class="sd">        :param init_pdf: either :class:`~pybayes.pdfs.EmpPdf` instance that will be used</span>
<span class="sd">            directly as a posterior (and should already have initial particles sampled) or</span>
<span class="sd">            any other probability density which initial particles are sampled from</span>
<span class="sd">        :type init_pdf: :class:`~pybayes.pdfs.Pdf`</span>
<span class="sd">        :param p_xt_xtp: :math:`p(x_t|x_{t-1})` cpdf of state in *t* given state in *t-1*</span>
<span class="sd">        :type p_xt_xtp: :class:`~pybayes.pdfs.CPdf`</span>
<span class="sd">        :param p_yt_xt: :math:`p(y_t|x_t)` cpdf of observation in *t* given state in *t*</span>
<span class="sd">        :type p_yt_xt: :class:`~pybayes.pdfs.CPdf`</span>
<span class="sd">        :param proposal: (optional) a filter whose posterior will be used to sample</span>
<span class="sd">            particles in :meth:`bayes` from (and to correct their weights). More specifically,</span>
<span class="sd">            its :meth:`bayes &lt;Filter.bayes&gt;` :math:`\left(y_t, x_{t-1}^{(i)}\right)` method is called before sampling</span>
<span class="sd">            i-th particle. Each call to ``bayes()`` should therefore reset any effects of</span>
<span class="sd">            the previous call.</span>
<span class="sd">        :type proposal: :class:`Filter`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;n must be a positive integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_pdf</span><span class="p">,</span> <span class="n">Pdf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;init_pdf must be an instance ot the Pdf class&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_xt_xtp</span><span class="p">,</span> <span class="n">CPdf</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_yt_xt</span><span class="p">,</span> <span class="n">CPdf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;both p_xt_xtp and p_yt_xt must be instances of the CPdf class&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Filter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;proposal must by Filter instance&quot;</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">init_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>  <span class="c"># dimension of state</span>
        <span class="k">if</span> <span class="n">p_xt_xtp</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">dim</span> <span class="ow">or</span> <span class="n">p_xt_xtp</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected shape() and cond_shape() of p_xt_xtp will &quot;</span>
                <span class="o">+</span> <span class="s">&quot;be (respectively greater than) {0}; ({1}, {2}) given.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">p_xt_xtp</span><span class="o">.</span><span class="n">shape</span><span class="p">(),</span> <span class="n">p_xt_xtp</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_xt_xtp</span> <span class="o">=</span> <span class="n">p_xt_xtp</span>
        <span class="k">if</span> <span class="n">p_yt_xt</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected cond_shape() of p_yt_xt will be {0}; {1} given.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p_yt_xt</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_yt_xt</span> <span class="o">=</span> <span class="n">p_yt_xt</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_pdf</span><span class="p">,</span> <span class="n">EmpPdf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emp</span> <span class="o">=</span> <span class="n">init_pdf</span>  <span class="c"># use directly</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emp</span> <span class="o">=</span> <span class="n">EmpPdf</span><span class="p">(</span><span class="n">init_pdf</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>

</div>
<div class="viewcode-block" id="ParticleFilter.bayes"><a class="viewcode-back" href="../../filters.html#pybayes.filters.ParticleFilter.bayes">[docs]</a>    <span class="k">def</span> <span class="nf">bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Perform Bayes rule for new measurement :math:`y_t`; *cond* is ignored.</span>

<span class="sd">        :param numpy.ndarray cond: optional condition that is passed to :math:`p(x_t|x_{t-1})`</span>
<span class="sd">          after :math:`x_{t-1}` so that is can be rewritten as: :math:`p(x_t|x_{t-1}, c)`.</span>

<span class="sd">        The algorithm is as follows:</span>

<span class="sd">        1. generate new particles: :math:`x_t^{(i)} = \text{sample from }</span>
<span class="sd">           p(x_t^{(i)}|x_{t-1}^{(i)}) \quad \forall i`</span>
<span class="sd">        2. recompute weights: :math:`\omega_i = p(y_t|x_t^{(i)})</span>
<span class="sd">           \omega_i \quad \forall i`</span>
<span class="sd">        3. normalise weights</span>
<span class="sd">        4. resample particles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">bayes</span><span class="p">(</span><span class="n">yt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">proposal_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">posterior</span><span class="p">()</span>  <span class="c"># gives unconditional Pdf, doesn&#39;t hurt</span>
                <span class="n">x_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c"># we need to save previous particle in this case</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proposal_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_xt_xtp</span>  <span class="c"># naive (transition) proposal</span>

            <span class="c"># generate new ith particle:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">transition_using</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">proposal_pdf</span><span class="p">)</span>

            <span class="c"># recompute ith weight:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_yt_xt</span><span class="o">.</span><span class="n">eval_log</span><span class="p">(</span><span class="n">yt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># non-naive proposal was used, corrent the weight</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_xt_xtp</span><span class="o">.</span><span class="n">eval_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x_tp</span><span class="p">))</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">proposal_pdf</span><span class="o">.</span><span class="n">eval_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">denom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c"># TODO: what to do in this case?</span>

        <span class="c"># assure that weights are normalised</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">normalise_weights</span><span class="p">()</span>
        <span class="c"># resample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emp</span><span class="o">.</span><span class="n">resample</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emp</span>

</div>
<div class="viewcode-block" id="MarginalizedParticleFilter"><a class="viewcode-back" href="../../filters.html#pybayes.filters.MarginalizedParticleFilter">[docs]</a><span class="k">class</span> <span class="nc">MarginalizedParticleFilter</span><span class="p">(</span><span class="n">Filter</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Simple marginalized particle filter implementation. Assume that tha state vector :math:`x`</span>
<span class="sd">    can be divided into two parts :math:`x_t = (a_t, b_t)` and that the pdf representing the process</span>
<span class="sd">    model can be factorised as follows:</span>

<span class="sd">    .. math:: p(x_t|x_{t-1}) = p(a_t|a_{t-1}, b_t) p(b_t | b_{t-1})</span>

<span class="sd">    and that the :math:`a_t` part (given :math:`b_t`) can be estimated with (a subbclass of) the</span>
<span class="sd">    :class:`KalmanFilter`. Such system may be suitable for the marginalized particle filter, whose</span>
<span class="sd">    posterior pdf takes the form</span>

<span class="sd">    .. math::</span>

<span class="sd">       p &amp;= \sum_{i=1}^n \omega_i p(a_t | y_{1:t}, b_{1:t}^{(i)}) \delta(b_t - b_t^{(i)}) \\</span>
<span class="sd">       p(a_t | y_{1:t}, b_{1:t}^{(i)}) &amp;\text{ is posterior pdf of i}^{th} \text{ Kalman filter} \\</span>
<span class="sd">       \text{where } \quad \quad \quad \quad \quad</span>
<span class="sd">       b_t^{(i)} &amp;\text{ is value of the (b part of the) i}^{th} \text{ particle} \\</span>
<span class="sd">       \omega_i \geq 0 &amp;\text{ is weight of the i}^{th} \text{ particle} \quad \sum \omega_i = 1</span>

<span class="sd">    **Note:** currently :math:`b_t` is hard-coded to be process and observation noise covariance of the</span>
<span class="sd">    :math:`a_t` part. This will be changed soon and :math:`b_t` will be passed as condition to</span>
<span class="sd">    :meth:`KalmanFilter.bayes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MarginalizedParticleFilter.__init__"><a class="viewcode-back" href="../../filters.html#pybayes.filters.MarginalizedParticleFilter.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">init_pdf</span><span class="p">,</span> <span class="n">p_bt_btp</span><span class="p">,</span> <span class="n">kalman_args</span><span class="p">,</span> <span class="n">kalman_class</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Initialise marginalized particle filter.</span>

<span class="sd">        :param int n: number of particles</span>
<span class="sd">        :param init_pdf: probability density which initial particles are sampled from. (both</span>
<span class="sd">           :math:`a_t` and :math:`b_t` parts)</span>
<span class="sd">        :type init_pdf: :class:`~pybayes.pdfs.Pdf`</span>
<span class="sd">        :param p_bt_btp: :math:`p(b_t|b_{t-1})` cpdf of the (b part of the) state in *t* given</span>
<span class="sd">           state in *t-1*</span>
<span class="sd">        :type p_bt_btp: :class:`~pybayes.pdfs.CPdf`</span>
<span class="sd">        :param dict kalman_args: arguments for the Kalman filter, passed as dictionary; *state_pdf*</span>
<span class="sd">           key should not be speficied as it is supplied by the marginalized particle filter</span>
<span class="sd">        :param class kalman_class: class of the filter used for the :math:`a_t` part of the system;</span>
<span class="sd">            defaults to :class:`KalmanFilter`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;n must be a positive integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_pdf</span><span class="p">,</span> <span class="n">Pdf</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_bt_btp</span><span class="p">,</span> <span class="n">CPdf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;init_pdf must be a Pdf and p_bt_btp must be a CPdf&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">kalman_class</span><span class="p">,</span> <span class="n">KalmanFilter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;kalman_class must be a subclass (not an instance) of KalmanFilter&quot;</span><span class="p">)</span>
        <span class="n">b_shape</span> <span class="o">=</span> <span class="n">p_bt_btp</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p_bt_btp</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">b_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;p_bt_btp&#39;s shape ({0}) and cond shape ({1}) must both be {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="n">p_bt_btp</span><span class="o">.</span><span class="n">shape</span><span class="p">(),</span> <span class="n">p_bt_btp</span><span class="o">.</span><span class="n">cond_shape</span><span class="p">(),</span> <span class="n">b_shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_bt_btp</span> <span class="o">=</span> <span class="n">p_bt_btp</span>
        <span class="n">a_shape</span> <span class="o">=</span> <span class="n">init_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">-</span> <span class="n">b_shape</span>

        <span class="c"># this will be removed when hardcoding Q,R into kalman filter will be removed</span>
        <span class="n">kalman_args</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">123.</span><span class="p">]])</span>
        <span class="n">kalman_args</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">494658.</span><span class="p">]])</span>

        <span class="c"># generate both initial parts of particles</span>
        <span class="n">init_particles</span> <span class="o">=</span> <span class="n">init_pdf</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c"># create all Kalman filters first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">KalmanFilter</span><span class="p">)</span> <span class="c"># array of references to Kalman filters</span>
        <span class="n">gausses</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">GaussPdf</span><span class="p">)</span> <span class="c"># array of Kalman filter state pdfs</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">gausses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">GaussPdf</span><span class="p">(</span><span class="n">init_particles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">a_shape</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">]]))</span>
            <span class="n">kalman_args</span><span class="p">[</span><span class="s">&#39;state_pdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gausses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kalman_class</span><span class="p">(</span><span class="o">**</span><span class="n">kalman_args</span><span class="p">)</span>
        <span class="c"># construct apost pdf. Important: reference to ith GaussPdf is shared between ith Kalman</span>
        <span class="c"># filter&#39;s state_pdf and ith memp&#39;t gauss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memp</span> <span class="o">=</span> <span class="n">MarginalizedEmpPdf</span><span class="p">(</span><span class="n">gausses</span><span class="p">,</span> <span class="n">init_particles</span><span class="p">[:,</span><span class="n">a_shape</span><span class="p">:])</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot;  {0}: {1:0&lt;5.3f} * {2} {3}    kf.S: {4}</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">gausses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># trim the last newline</span>

<div class="viewcode-block" id="MarginalizedParticleFilter.bayes"><a class="viewcode-back" href="../../filters.html#pybayes.filters.MarginalizedParticleFilter.bayes">[docs]</a>    <span class="k">def</span> <span class="nf">bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Perform Bayes rule for new measurement :math:`y_t`. Uses following algorithm:</span>

<span class="sd">        1. generate new b parts of particles: :math:`b_t^{(i)} = \text{sample from }</span>
<span class="sd">           p(b_t^{(i)}|b_{t-1}^{(i)}) \quad \forall i`</span>
<span class="sd">        2. :math:`\text{set } Q_i = b_t^{(i)} \quad R_i = b_t^{(i)}` where :math:`Q_i, R_i` is</span>
<span class="sd">           covariance of process (respectively observation) noise in ith Kalman filter.</span>
<span class="sd">        3. perform Bayes rule for each Kalman filter using passed observation :math:`y_t`</span>
<span class="sd">        4. recompute weights: :math:`\omega_i = p(y_t | y_{1:t-1}, b_t^{(i)}) \omega_i` where</span>
<span class="sd">           :math:`p(y_t | y_{1:t-1}, b_t^{(i)})` is *evidence* (*marginal likelihood*) pdf of ith Kalman</span>
<span class="sd">           filter.</span>
<span class="sd">        5. normalise weights</span>
<span class="sd">        6. resample particles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c"># generate new b_t</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_bt_btp</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c"># assign b_t to kalman filter</span>
            <span class="c"># TODO: more general and correct apprach would be some kind of QRKalmanFilter that would</span>
            <span class="c"># accept b_t in condition. This is planned in future.</span>
            <span class="n">kalman</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">kalman</span><span class="o">.</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">kalman</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">kalman</span><span class="o">.</span><span class="n">bayes</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">exp</span><span class="p">(</span><span class="n">kalman</span><span class="o">.</span><span class="n">evidence_log</span><span class="p">(</span><span class="n">yt</span><span class="p">))</span>

        <span class="c"># make sure that weights are normalised</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">normalise_weights</span><span class="p">()</span>
        <span class="c"># resample particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resample</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">get_resample_indices</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reindex_vv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>  <span class="c"># resample kalman filters (makes references, not hard copies)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reindex_mv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>  <span class="c"># resample particles</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>  <span class="c"># copy only when needed</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c"># we need to deep copy ith kalman</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">gausses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">P</span>  <span class="c"># reassign reference to correct (new) state pdf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">memp</span><span class="o">.</span><span class="n">weights</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">kalmans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># set weights to 1/n</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memp</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">PyBayes 0.3-96-g0efa257
 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Matj Laitl.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>